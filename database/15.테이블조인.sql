/*
    테이블 조인(TABLE JOIN)
    - 분리되어 있는 테이블을 특정 기준에 의해서 합치는 것
    - 합칠 때의 기준이 있어야 함
    - 연관이 있는 테이블을 함쳐야 한다.
*/
-- 아래 코드는 의미가 없다
-- SELECT * FROM POCKETMON, STUDENT; (크로스 조인)

-- 연습용 테이블 생성(학원과 강의장)
CREATE TABLE ACADEMY(
ACADEMY_NO NUMBER PRIMARY KEY,
ACADEMY_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO ACADEMY(
    ACADEMY_NO, ACADEMY_NAME
        ) VALUES(100,'KH강남점');
INSERT INTO ACADEMY(
    ACADEMY_NO, ACADEMY_NAME
        ) VALUES(200,'KH당산점');
INSERT INTO ACADEMY(
    ACADEMY_NO, ACADEMY_NAME
        ) VALUES(300,'KH종로점');
COMMIT;

CREATE TABLE ROOM(
ROOM_NO NUMBER PRIMARY KEY,
ROOM_NAME VARCHAR2(30) NOT NULL,
ROOM_SIZE NUMBER NOT NULL,
ACADEMY_NO REFERENCES ACADEMY(ACADEMY_NO) ON DELETE CASCADE
);
INSERT INTO ROOM(
    ROOM_NO, ROOM_NAME, ROOM_SIZE, ACADEMY_NO
        ) VALUES(1,'A강의장',10,200);
        INSERT INTO ROOM(
    ROOM_NO, ROOM_NAME, ROOM_SIZE, ACADEMY_NO
        ) VALUES(2,'B강의장',20,200);
        INSERT INTO ROOM(
    ROOM_NO, ROOM_NAME, ROOM_SIZE, ACADEMY_NO
        ) VALUES(3,'C강의장',20,200);
        INSERT INTO ROOM(
    ROOM_NO, ROOM_NAME, ROOM_SIZE, ACADEMY_NO
        ) VALUES(4,'D강의장',10,100);
        INSERT INTO ROOM(
    ROOM_NO, ROOM_NAME, ROOM_SIZE, ACADEMY_NO
        ) VALUES(5,'E강의장',10,100);
        
        COMMIT;
        
-- INNER JOIN은 연결된 데이터만 조회가 가능하다
-- 구문 : SELECT 항목 FROM A테이블 INNER JOIN B테이블 ON 연결조건
-- (주의!) 중복되는 컬럼명을 제거하거나 별칭으로 변경해야 함

-- SELECT*FROM ACADEMY+ROOM;
SELECT ACADEMY.*,ROOM.ROOM_NO, ROOM.ROOM_NAME, ROOM.ROOM_SIZE
FROM ACADEMY INNER JOIN ROOM 
ON ACADEMY.ACADEMY_NO = ROOM.ACADEMY_NO;

-- 별칭 추가
SELECT A.*,R.ROOM_NO, R.ROOM_NAME, R.ROOM_SIZE
FROM ACADEMY A INNER JOIN ROOM R 
ON A.ACADEMY_NO = R.ACADEMY_NO;

-- 문제 : 게시글 조회 시 회원 닉네임이 같이 조회
-- 문제점) 회원이 탈퇴하여 작성자가 NULL이 되면 조회가 이루어지지 않는다
-- 해결책) OUTER JOIN 사용
SELECT B.*,M.MEMBER_NICK
FROM BOARD B INNER JOIN MEMBER M ON B.BOARD_WRITER = M.MEMBER_ID;

-- OUTER JOIN은 특정 테이블을 기준으로 하여 연관된 데이터를 합쳐 조회한다.
-- 기준 테이블이 어느 위치에 있느냐에 따라 방향이 결정된다.
-- A ← B면 A LEFT OUTER JOIN B
-- A → B면 A RIGHT OUTER JOIN B
-- A ↔ B면 A FULL OUTER JOIN B
-- 기준 테이블은 연관 데이터가 없어도 모두 조회가 된다

-- EX : 학원을 기준으로 강의장 정보까지조회
SELECT A.*,R.ROOM_NO,R.ROOM_NAME
FROM 
    ACADEMY A LEFT OUTER JOIN ROOM R 
        ON A.ACADEMY_NO = R.ACADEMY_NO;
        
-- EX : 확원 별 강의장 개수를 출력
-- (주의!) COUNT(*)를 사용하면 NULL이 카운팅된다.
SELECT A.ACADEMY_NAME, COUNT(R.ROOM_NO)
FROM ACADEMY A LEFT OUTER JOIN ROOM R ON A.ACADEMY_NO = R.ACADEMY_NO
GROUP BY A.ACADEMY_NAME;

-- 문제 : 회원별 게시글 작성 개수 출력
SELECT M.MEMBER_ID, COUNT(B.BOARD_NO) CNT
FROM MEMBER M LEFT OUTER JOIN BOARD B ON M.MEMBER_ID = B.BOARD_WRITER
GROUP BY M.MEMBER_ID 
ORDER BY CNT DESC;


-- 문제 : 포켓몬스터 정보와 이미지 번호를 출력
SELECT P.*, PI.ATTACHMENT_NO
FROM POCKETMON P LEFT OUTER JOIN POCKETMON_IMAGE PI ON P.NO = PI.POCKETMON_NO;

-- 문제 : 게시글 정보와 회원 닉네임 , 프로필 이미지를 조회 
SELECT B.BOARD_NO,M.MEMBER_NICK, MP.ATTACHMENT_NO
FROM BOARD B
    LEFT OUTER JOIN MEMBER M ON B.BOARD_WRITER = M.MEMBER_ID
--    LEFT OUTER JOIN MEMBER_PROFILE MP ON B.BOARD_WRITER = MP.MEMBER_ID;
      LEFT OUTER JOIN MEMBER_PROFILE MP ON M.MEMBER_ID = MP.MEMBER_ID;
      
-- 포켓몬스터 정보와 이미지 번호를 함께 조회하는 뷰
create view pocketmon_with_image as
SELECT P.*, PI.ATTACHMENT_NO
FROM POCKETMON P LEFT OUTER JOIN POCKETMON_IMAGE PI ON P.NO = PI.POCKETMON_NO;

select*from pocketmon_with_image;